apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls the user and group IDs of the container.
  name: k8spspallowedusers
spec:
  crd:
    spec:
      names:
        kind: K8sPSPAllowedUsers
      validation:
        openAPIV3Schema:
          properties:
            fsGroup:
              properties:
                ranges:
                  items:
                    properties:
                      max:
                        type: integer
                      min:
                        type: integer
                    type: object
                  type: array
                rule:
                  type: string
              type: object
            runAsGroup:
              properties:
                ranges:
                  items:
                    properties:
                      max:
                        type: integer
                      min:
                        type: integer
                    type: object
                  type: array
                rule:
                  type: string
              type: object
            runAsUser:
              properties:
                ranges:
                  items:
                    properties:
                      max:
                        type: integer
                      min:
                        type: integer
                    type: object
                  type: array
                rule:
                  type: string
              type: object
            supplementalGroups:
              properties:
                ranges:
                  items:
                    properties:
                      max:
                        type: integer
                      min:
                        type: integer
                    type: object
                  type: array
                rule:
                  type: string
              type: object
  targets:
  - rego: |
      package k8spspallowedusers

      violation[{"msg": msg}] {
        fields := ["runAsUser", "runAsGroup", "supplementalGroups", "fsGroup"]
        field := fields[_]
        container := input_containers[_]
        msg := get_type_violation(field, container)
      }

      get_type_violation(field, container) = msg {
        field == "runAsUser"
        params := input.parameters[field]
        msg := get_user_violation(params, container)
      }

      get_type_violation(field, container) = msg {
        field != "runAsUser"
        params := input.parameters[field]
        msg := get_violation(field, params, container)
      }

      # RunAsUser (separate due to "MustRunAsNonRoot")
      get_user_violation(params, container) = msg {
        rule := params.rule
        provided_user := get_field_value("runAsUser", container, input.review)
        not accept_users(rule, provided_user)
        msg := sprintf("Container %v is attempting to run as disallowed user %v. Allowed runAsUser: %v", [container.name, provided_user, params])
      }

      get_user_violation(params, container) = msg {
        not get_field_value("runAsUser", container, input.review)
        params.rule = "MustRunAs"
        msg := sprintf("Container %v is attempting to run without a required securityContext/runAsUser", [container.name])
      }

      get_user_violation(params, container) = msg {
        params.rule = "MustRunAsNonRoot"
        not get_field_value("runAsUser", container, input.review)
        not get_field_value("runAsNonRoot", container, input.review)
        msg := sprintf("Container %v is attempting to run without a required securityContext/runAsNonRoot or securityContext/runAsUser != 0", [container.name])
      }

      accept_users("RunAsAny", provided_user) {true}

      accept_users("MustRunAsNonRoot", provided_user) = res {res := provided_user != 0}

      accept_users("MustRunAs", provided_user) = res  {
        ranges := input.parameters.runAsUser.ranges
        res := is_in_range(provided_user, ranges)
      }

      # Group Options
      get_violation(field, params, container) = msg {
        rule := params.rule
        provided_value := get_field_value(field, container, input.review)
        not is_array(provided_value)
        not accept_value(rule, provided_value, params.ranges)
        msg := sprintf("Container %v is attempting to run as disallowed group %v. Allowed %v: %v", [container.name, provided_value, field, params])
      }
      # SupplementalGroups is array value
      get_violation(field, params, container) = msg {
        rule := params.rule
        array_value := get_field_value(field, container, input.review)
        is_array(array_value)
        provided_value := array_value[_]
        not accept_value(rule, provided_value, params.ranges)
        msg := sprintf("Container %v is attempting to run with disallowed supplementalGroups %v. Allowed %v: %v", [container.name, array_value, field, params])
      }

      get_violation(field, params, container) = msg {
        not get_field_value(field, container, input.review)
        params.rule == "MustRunAs"
        msg := sprintf("Container %v is attempting to run without a required securityContext/%v. Allowed %v: %v", [container.name, field, field, params])
      }

      accept_value("RunAsAny", provided_value, ranges) {true}

      accept_value("MayRunAs", provided_value, ranges) = res { res := is_in_range(provided_value, ranges)}

      accept_value("MustRunAs", provided_value, ranges) = res { res := is_in_range(provided_value, ranges)}


      # If container level is provided, that takes precedence
      get_field_value(field, container, review) = out {
        container_value := get_seccontext_field(field, container)
        out := container_value
      }

      # If no container level exists, use pod level
      get_field_value(field, container, review) = out {
        not has_seccontext_field(field, container)
        review.kind.kind == "Pod"
        pod_value := get_seccontext_field(field, review.object.spec)
        out := pod_value
      }

      # Helper Functions
      is_in_range(val, ranges) = res {
        matching := {1 | val >= ranges[j].min; val <= ranges[j].max}
        res := count(matching) > 0
      }

      has_seccontext_field(field, obj) {
        get_seccontext_field(field, obj)
      }

      has_seccontext_field(field, obj) {
        get_seccontext_field(field, obj) == false
      }

      get_seccontext_field(field, obj) = out {
        out = obj.securityContext[field]
      }

      input_containers[c] {
        c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
        c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls restricting escalation to root privileges.
  name: k8spspallowprivilegeescalationcontainer
spec:
  crd:
    spec:
      names:
        kind: K8sPSPAllowPrivilegeEscalationContainer
  targets:
  - rego: |
      package k8spspallowprivilegeescalationcontainer

      violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          input_allow_privilege_escalation(c)
          msg := sprintf("Privilege escalation container is not allowed: %v", [c.name])
      }

      input_allow_privilege_escalation(c) {
          not has_field(c, "securityContext")
      }
      input_allow_privilege_escalation(c) {
          not c.securityContext.allowPrivilegeEscalation == false
      }
      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls the AppArmor profile used by containers.
  name: k8spspapparmor
spec:
  crd:
    spec:
      names:
        kind: K8sPSPAppArmor
      validation:
        openAPIV3Schema:
          properties:
            allowedProfiles:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8spspapparmor

      violation[{"msg": msg, "details": {}}] {
          metadata := input.review.object.metadata
          container := input_containers[_]
          not input_apparmor_allowed(container, metadata)
          msg := sprintf("AppArmor profile is not allowed, pod: %v, container: %v. Allowed profiles: %v", [input.review.object.metadata.name, container.name, input.parameters.allowedProfiles])
      }

      input_apparmor_allowed(container, metadata) {
          metadata.annotations[key] == input.parameters.allowedProfiles[_]
          key == sprintf("container.apparmor.security.beta.kubernetes.io/%v", [container.name])
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls Linux capabilities.
  name: k8spspcapabilities
spec:
  crd:
    spec:
      names:
        kind: K8sPSPCapabilities
      validation:
        openAPIV3Schema:
          properties:
            allowedCapabilities:
              items:
                type: string
              type: array
            requiredDropCapabilities:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package capabilities

      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        has_disallowed_capabilities(container)
        msg := sprintf("container <%v> has a disallowed capability. Allowed capabilities are %v", [container.name, get_default(input.parameters, "allowedCapabilities", "NONE")])
      }

      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        missing_drop_capabilities(container)
        msg := sprintf("container <%v> is not dropping all required capabilities. Container must drop all of %v", [container.name, input.parameters.requiredDropCapabilities])
      }



      violation[{"msg": msg}] {
        container := input.review.object.spec.initContainers[_]
        has_disallowed_capabilities(container)
        msg := sprintf("init container <%v> has a disallowed capability. Allowed capabilities are %v", [container.name, get_default(input.parameters, "allowedCapabilities", "NONE")])
      }

      violation[{"msg": msg}] {
        container := input.review.object.spec.initContainers[_]
        missing_drop_capabilities(container)
        msg := sprintf("init container <%v> is not dropping all required capabilities. Container must drop all of %v", [container.name, input.parameters.requiredDropCapabilities])
      }


      has_disallowed_capabilities(container) {
        allowed := {c | c := input.parameters.allowedCapabilities[_]}
        not allowed["*"]
        capabilities := {c | c := container.securityContext.capabilities.add[_]}
        count(capabilities - allowed) > 0
      }

      missing_drop_capabilities(container) {
        must_drop := {c | c := input.parameters.requiredDropCapabilities[_]}
        dropped := {c | c := container.securityContext.capabilities.drop[_]}
        count(must_drop - dropped) > 0
      }

      get_default(obj, param, _default) = out {
        out = obj[param]
      }

      get_default(obj, param, _default) = out {
        not obj[param]
        not obj[param] == false
        out = _default
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls the allowlist of Flexvolume drivers.
  name: k8spspflexvolumes
spec:
  crd:
    spec:
      names:
        kind: K8sPSPFlexVolumes
      validation:
        openAPIV3Schema:
          properties:
            allowedFlexVolumes:
              items:
                properties:
                  driver:
                    type: string
                type: object
              type: array
  targets:
  - rego: |
      package k8spspflexvolumes

      violation[{"msg": msg, "details": {}}] {
          volume := input_flexvolumes[_]
          not input_flexvolumes_allowed(volume)
          msg := sprintf("FlexVolume %v is not allowed, pod: %v. Allowed drivers: %v", [volume, input.review.object.metadata.name, input.parameters.allowedFlexVolumes])
      }

      input_flexvolumes_allowed(volume) {
          input.parameters.allowedFlexVolumes[_].driver == volume.flexVolume.driver
      }

      input_flexvolumes[v] {
          v := input.review.object.spec.volumes[_]
          has_field(v, "flexVolume")
      }

      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls the `sysctl` profile used by containers.
  name: k8spspforbiddensysctls
spec:
  crd:
    spec:
      names:
        kind: K8sPSPForbiddenSysctls
      validation:
        openAPIV3Schema:
          properties:
            forbiddenSysctls:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8spspforbiddensysctls

      violation[{"msg": msg, "details": {}}] {
          sysctl := input.review.object.spec.securityContext.sysctls[_].name
          forbidden_sysctl(sysctl)
          msg := sprintf("The sysctl %v is not allowed, pod: %v. Forbidden sysctls: %v", [sysctl, input.review.object.metadata.name, input.parameters.forbiddenSysctls])
      }

      # * may be used to forbid all sysctls
      forbidden_sysctl(sysctl) {
          input.parameters.forbiddenSysctls[_] == "*"
      }

      forbidden_sysctl(sysctl) {
          input.parameters.forbiddenSysctls[_] == sysctl
      }

      forbidden_sysctl(sysctl) {
          startswith(sysctl, trim(input.parameters.forbiddenSysctls[_], "*"))
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls allocating an FSGroup that owns the Pod's volumes.
  name: k8spspfsgroup
spec:
  crd:
    spec:
      names:
        kind: K8sPSPFSGroup
      validation:
        openAPIV3Schema:
          properties:
            ranges:
              items:
                properties:
                  max:
                    type: integer
                  min:
                    type: integer
                type: object
              type: array
            rule:
              type: string
  targets:
  - rego: |
      package k8spspfsgroup

      violation[{"msg": msg, "details": {}}] {
        spec := input.review.object.spec
        not input_fsGroup_allowed(spec)
        msg := sprintf("The provided pod spec fsGroup is not allowed, pod: %v. Allowed fsGroup: %v", [input.review.object.metadata.name, input.parameters])
      }

      input_fsGroup_allowed(spec) {
        # RunAsAny - No range is required. Allows any fsGroup ID to be specified.
        input.parameters.rule == "RunAsAny"
      }
      input_fsGroup_allowed(spec) {
        # MustRunAs - Validates pod spec fsgroup against all ranges
        input.parameters.rule == "MustRunAs"
        fg := spec.securityContext.fsGroup
        count(input.parameters.ranges) > 0
        range := input.parameters.ranges[_]
        value_within_range(range, fg)
      }
      input_fsGroup_allowed(spec) {
          # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
          input.parameters.rule == "MayRunAs"
          not has_field(spec, "securityContext")
      }
      input_fsGroup_allowed(spec) {
          # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
          input.parameters.rule == "MayRunAs"
          not spec.securityContext.fsGroup
      }
      input_fsGroup_allowed(spec) {
        # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
        input.parameters.rule == "MayRunAs"
        fg := spec.securityContext.fsGroup
        count(input.parameters.ranges) > 0
        range := input.parameters.ranges[_]
        value_within_range(range, fg)
      }
      value_within_range(range, value) {
        range.min <= value
        range.max >= value
      }
      # has_field returns whether an object has a field
      has_field(object, field) = true {
        object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls usage of the host filesystem.
  name: k8spsphostfilesystem
spec:
  crd:
    spec:
      names:
        kind: K8sPSPHostFilesystem
      validation:
        openAPIV3Schema:
          properties:
            allowedHostPaths:
              items:
                properties:
                  pathPrefix:
                    type: string
                  readOnly:
                    type: boolean
                type: object
              type: array
  targets:
  - rego: |
      package k8spsphostfilesystem

      violation[{"msg": msg, "details": {}}] {
          volume := input_hostpath_volumes[_]
          allowedPaths := get_allowed_paths(input)
          input_hostpath_violation(allowedPaths, volume)
          msg := sprintf("HostPath volume %v is not allowed, pod: %v. Allowed path: %v", [volume, input.review.object.metadata.name, allowedPaths])
      }

      input_hostpath_violation(allowedPaths, volume) {
          # An empty list means all host paths are blocked
          allowedPaths == []
      }
      input_hostpath_violation(allowedPaths, volume) {
          not input_hostpath_allowed(allowedPaths, volume)
      }

      get_allowed_paths(arg) = out {
          not arg.parameters
          out = []
      }
      get_allowed_paths(arg) = out {
          not arg.parameters.allowedHostPaths
          out = []
      }
      get_allowed_paths(arg) = out {
          out = arg.parameters.allowedHostPaths
      }

      input_hostpath_allowed(allowedPaths, volume) {
          allowedHostPath := allowedPaths[_]
          path_matches(allowedHostPath.pathPrefix, volume.hostPath.path)
          not allowedHostPath.readOnly == true
      }

      input_hostpath_allowed(allowedPaths, volume) {
          allowedHostPath := allowedPaths[_]
          path_matches(allowedHostPath.pathPrefix, volume.hostPath.path)
          allowedHostPath.readOnly
          not writeable_input_volume_mounts(volume.name)
      }

      writeable_input_volume_mounts(volume_name) {
          container := input_containers[_]
          mount := container.volumeMounts[_]
          mount.name == volume_name
          not mount.readOnly
      }

      # This allows "/foo", "/foo/", "/foo/bar" etc., but
      # disallows "/fool", "/etc/foo" etc.
      path_matches(prefix, path) {
          a := split(trim(prefix, "/"), "/")
          b := split(trim(path, "/"), "/")
          prefix_matches(a, b)
      }
      prefix_matches(a, b) {
          count(a) <= count(b)
          not any_not_equal_upto(a, b, count(a))
      }

      any_not_equal_upto(a, b, n) {
          a[i] != b[i]
          i < n
      }

      input_hostpath_volumes[v] {
          v := input.review.object.spec.volumes[_]
          has_field(v, "hostPath")
      }

      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }

      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls usage of host namespaces.
  name: k8spsphostnamespace
spec:
  crd:
    spec:
      names:
        kind: K8sPSPHostNamespace
  targets:
  - rego: |
      package k8spsphostnamespace

      violation[{"msg": msg, "details": {}}] {
          input_share_hostnamespace(input.review.object)
          msg := sprintf("Sharing the host namespace is not allowed: %v", [input.review.object.metadata.name])
      }

      input_share_hostnamespace(o) {
          o.spec.hostPID
      }
      input_share_hostnamespace(o) {
          o.spec.hostIPC
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls usage of host networking and ports.
  name: k8spsphostnetworkingports
spec:
  crd:
    spec:
      names:
        kind: K8sPSPHostNetworkingPorts
      validation:
        openAPIV3Schema:
          properties:
            hostNetwork:
              type: boolean
            max:
              type: integer
            min:
              type: integer
  targets:
  - rego: |
      package k8spsphostnetworkingports

      violation[{"msg": msg, "details": {}}] {
        input_share_hostnetwork(input.review.object)
        msg := sprintf("The specified hostNetwork and hostPort are not allowed, pod: %v. Allowed values: %v", [input.review.object.metadata.name, input.parameters])
      }

      input_share_hostnetwork(o) {
        not input.parameters.hostNetwork
        o.spec.hostNetwork
      }

      input_share_hostnetwork(o) {
        hostPort := input_containers[_].ports[_].hostPort
        hostPort < input.parameters.min
      }

      input_share_hostnetwork(o) {
        hostPort := input_containers[_].ports[_].hostPort
        hostPort > input.parameters.max
      }

      input_containers[c] {
        c := input.review.object.spec.containers[_]
      }

      input_containers[c] {
        c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls running of privileged containers.
  name: k8spspprivilegedcontainer
spec:
  crd:
    spec:
      names:
        kind: K8sPSPPrivilegedContainer
  targets:
  - rego: |
      package k8spspprivileged

      violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          c.securityContext.privileged
          msg := sprintf("Privileged container is not allowed: %v, securityContext: %v", [c.name, c.securityContext])
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }

      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls the allowed `procMount` types for the container.
  name: k8spspprocmount
spec:
  crd:
    spec:
      names:
        kind: K8sPSPProcMount
      validation:
        openAPIV3Schema:
          properties:
            procMount:
              type: string
  targets:
  - rego: |
      package k8spspprocmount

      violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          allowedProcMount := get_allowed_proc_mount(input)
          not input_proc_mount_type_allowed(allowedProcMount, c)
          msg := sprintf("ProcMount type is not allowed, container: %v. Allowed procMount types: %v", [c.name, allowedProcMount])
      }

      input_proc_mount_type_allowed(allowedProcMount, c) {
          allowedProcMount == "default"
          lower(c.securityContext.procMount) == "default"
      }
      input_proc_mount_type_allowed(allowedProcMount, c) {
          allowedProcMount == "unmasked"
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
          c.securityContext.procMount
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
          c.securityContext.procMount
      }

      get_allowed_proc_mount(arg) = out {
          not arg.parameters
          out = "default"
      }
      get_allowed_proc_mount(arg) = out {
          not arg.parameters.procMount
          out = "default"
      }
      get_allowed_proc_mount(arg) = out {
          not valid_proc_mount(arg.parameters.procMount)
          out = "default"
      }
      get_allowed_proc_mount(arg) = out {
          out = lower(arg.parameters.procMount)
      }

      valid_proc_mount(str) {
          lower(str) == "default"
      }
      valid_proc_mount(str) {
          lower(str) == "unmasked"
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Requires the use of a read only root file system.
  name: k8spspreadonlyrootfilesystem
spec:
  crd:
    spec:
      names:
        kind: K8sPSPReadOnlyRootFilesystem
  targets:
  - rego: |
      package k8spspreadonlyrootfilesystem

      violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          input_read_only_root_fs(c)
          msg := sprintf("only read-only root filesystem container is allowed: %v", [c.name])
      }

      input_read_only_root_fs(c) {
          not has_field(c, "securityContext")
      }
      input_read_only_root_fs(c) {
          not c.securityContext.readOnlyRootFilesystem == true
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }

      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls the seccomp profile used by containers.
  name: k8spspseccomp
spec:
  crd:
    spec:
      names:
        kind: K8sPSPSeccomp
      validation:
        openAPIV3Schema:
          properties:
            allowedProfiles:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8spspseccomp

      violation[{"msg": msg, "details": {}}] {
          metadata := input.review.object.metadata
          not input_wildcard_allowed(metadata)
          container := input_containers[_]
          not input_container_allowed(metadata, container)
          msg := sprintf("Seccomp profile is not allowed, pod: %v, container: %v, Allowed profiles: %v", [metadata.name, container.name, input.parameters.allowedProfiles])
      }

      input_wildcard_allowed(metadata) {
          input.parameters.allowedProfiles[_] == "*"
      }

      input_container_allowed(metadata, container) {
          not get_container_profile(metadata, container)
          metadata.annotations["seccomp.security.alpha.kubernetes.io/pod"] == input.parameters.allowedProfiles[_]
      }

      input_container_allowed(metadata, container) {
        profile := get_container_profile(metadata, container)
        profile == input.parameters.allowedProfiles[_]
      }

      get_container_profile(metadata, container) = profile {
        value := metadata.annotations[key]
          startswith(key, "container.seccomp.security.alpha.kubernetes.io/")
          [prefix, name] := split(key, "/")
          name == container.name
          profile = value
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls the SELinux context of the container.
  name: k8spspselinuxv2
spec:
  crd:
    spec:
      names:
        kind: K8sPSPSELinuxV2
      validation:
        openAPIV3Schema:
          properties:
            allowedSELinuxOptions:
              items:
                properties:
                  level:
                    type: string
                  role:
                    type: string
                  type:
                    type: string
                  user:
                    type: string
                type: object
              type: array
  targets:
  - rego: |
      package k8spspselinux

      # Disallow top level custom SELinux options
      violation[{"msg": msg, "details": {}}] {
          has_field(input.review.object.spec.securityContext, "seLinuxOptions")
          not input_seLinuxOptions_allowed(input.review.object.spec.securityContext.seLinuxOptions)
          msg := sprintf("SELinux options is not allowed, pod: %v. Allowed options: %v", [input.review.object.metadata.name, input.parameters.allowedSELinuxOptions])
      }
      # Disallow container level custom SELinux options
      violation[{"msg": msg, "details": {}}] {
          c := input_security_context[_]
          has_field(c.securityContext, "seLinuxOptions")
          not input_seLinuxOptions_allowed(c.securityContext.seLinuxOptions)
          msg := sprintf("SELinux options is not allowed, pod: %v, container %v. Allowed options: %v", [input.review.object.metadata.name, c.name, input.parameters.allowedSELinuxOptions])
      }

      input_seLinuxOptions_allowed(options) {
          params := input.parameters.allowedSELinuxOptions[_]
          field_allowed("level", options, params)
          field_allowed("role", options, params)
          field_allowed("type", options, params)
          field_allowed("user", options, params)
      }

      field_allowed(field, options, params) {
          params[field] == options[field]
      }
      field_allowed(field, options, params) {
          not has_field(options, field)
      }

      input_security_context[c] {
          c := input.review.object.spec.containers[_]
          has_field(c.securityContext, "seLinuxOptions")
      }
      input_security_context[c] {
          c := input.review.object.spec.initContainers[_]
          has_field(c.securityContext, "seLinuxOptions")
      }

      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  labels:
    {{- include "gatekeeper.labels" . | nindent 4 }}
  annotations:
    description: Controls usage of volume types.
  name: k8spspvolumetypes
spec:
  crd:
    spec:
      names:
        kind: K8sPSPVolumeTypes
      validation:
        openAPIV3Schema:
          properties:
            volumes:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8spspvolumetypes

      violation[{"msg": msg, "details": {}}] {
          volume_fields := {x | input.review.object.spec.volumes[_][x]; x != "name"}
          field := volume_fields[_]
          not input_volume_type_allowed(field)
          msg := sprintf("The volume type %v is not allowed, pod: %v. Allowed volume types: %v", [field, input.review.object.metadata.name, input.parameters.volumes])
      }

      # * may be used to allow all volume types
      input_volume_type_allowed(field) {
          input.parameters.volumes[_] == "*"
      }

      input_volume_type_allowed(field) {
          field == input.parameters.volumes[_]
      }
    target: admission.k8s.gatekeeper.sh
